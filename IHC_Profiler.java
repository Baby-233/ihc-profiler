import ij.*;
import ij.plugin.*;
import ij.plugin.frame.*;
import ij.process.*;
import ij.gui.*;
import java.awt.*;
import java.awt.image.*;

/*
This plugin implements stain separation using the colour deconvolution
method described in:

    Ruifrok AC, Johnston DA. Quantification of histochemical
    staining by color deconvolution. Analytical & Quantitative
    Cytology & Histology 2001; 23: 291-299.

The code is based on "Color separation-30", a macro for NIH Image kindly provided
by A.C. Ruifrok.

The plugin assumes images generated by color subtraction (i.e. light-absorbing dyes
such as those used in bright field histology or ink on printed paper) but the dyes
should not be neutral grey.

We strongly suggest to read the paper referenced above to understand how to determine
new vectors and how the whole procedure works.

The plugin works correctly when the background is neutral (white to light grey),
so background subtraction and colour correction must be applied to the images before
processing.
*/
public class IHC_Profiler implements PlugIn {

    private static String[] MODES = {"Cytoplasmic Stained Image", "Nuclear Stained Image"};
    private static String[] STAINS = {"H DAB"};

    public void run(String arg) {
        ImagePlus imp = WindowManager.getCurrentImage();
        if (imp == null) {
            IJ.error("No image!");
            return;
        }
        if (imp.getBitDepth() != 24) {
            IJ.error("RGB image needed.");
            return;
        }
        ImageStack stack = imp.getStack();
        int width = stack.getWidth();
        int height = stack.getHeight();
        String title = imp.getTitle();

        GenericDialog ge = new GenericDialog("IHC Profiler", IJ.getInstance());
        ge.addChoice("Mode", MODES, MODES[0]);
        ge.showDialog();
        if (ge.wasCanceled()) {
            return;
        }

        String myMode = ge.getNextChoice();
        boolean doIshw = ge.getNextBoolean();
        boolean hideLeg = ge.getNextBoolean();

        GenericDialog gd = new GenericDialog("Colour Deconvolution 1.5", IJ.getInstance());
        //gd.addMessage("Select subtractive colour model");
        gd.addChoice("Vectors", STAINS, STAINS[0]);
        //gd.addCheckbox("Show matrices",false);
        //gd.addCheckbox("Hide legend",false);
        //gd.addCheckbox("Linear image",false);

        gd.showDialog();
        if (gd.wasCanceled()) {
            return;
        }

        String myStain = gd.getNextChoice();
        boolean doIshow = gd.getNextBoolean();
        boolean hideLegend = gd.getNextBoolean();

        double length, A, V, C, log255 = Math.log(255.0);
        int i, j;
        double[] MODx = new double[3];
        double[] MODy = new double[3];
        double[] MODz = new double[3];
        double[] cosx = new double[3];
        double[] cosy = new double[3];
        double[] cosz = new double[3];
        double[] len = new double[3];
        double[] q = new double[9];
        byte[] rLUT = new byte[256];
        byte[] gLUT = new byte[256];
        byte[] bLUT = new byte[256];

        // define stains
        if (myStain.equals(STAINS[0])) {
            makeVectorHDAB(MODx, MODy, MODz);
        }

        // start
        for (i = 0; i < 3; i++) {
            //normalise vector length
            cosx[i] = cosy[i] = cosz[i] = 0.0;
            len[i] = Math.sqrt(MODx[i] * MODx[i] + MODy[i] * MODy[i] + MODz[i] * MODz[i]);
            if (len[i] != 0.0) {
                cosx[i] = MODx[i] / len[i];
                cosy[i] = MODy[i] / len[i];
                cosz[i] = MODz[i] / len[i];
            }
        }

        // translation matrix
        if (cosx[1] == 0.0) { //2nd colour is unspecified
            if (cosy[1] == 0.0) {
                if (cosz[1] == 0.0) {
                    cosx[1] = cosz[0];
                    cosy[1] = cosx[0];
                    cosz[1] = cosy[0];
                }
            }
        }

        if (cosx[2] == 0.0) { // 3rd colour is unspecified
            if (cosy[2] == 0.0) {
                if (cosz[2] == 0.0) {
                    if ((cosx[0] * cosx[0] + cosx[1] * cosx[1]) > 1) {
                        if (doIshow)
                            IJ.log("Colour_3 has a negative R component.");
                        cosx[2] = 0.0;
                    } else {
                        cosx[2] = Math.sqrt(1.0 - (cosx[0] * cosx[0]) - (cosx[1] * cosx[1]));
                    }

                    if ((cosy[0] * cosy[0] + cosy[1] * cosy[1]) > 1) {
                        if (doIshow)
                            IJ.log("Colour_3 has a negative G component.");
                        cosy[2] = 0.0;
                    } else {
                        cosy[2] = Math.sqrt(1.0 - (cosy[0] * cosy[0]) - (cosy[1] * cosy[1]));
                    }

                    if ((cosz[0] * cosz[0] + cosz[1] * cosz[1]) > 1) {
                        if (doIshow)
                            IJ.log("Colour_3 has a negative B component.");
                        cosz[2] = 0.0;
                    } else {
                        cosz[2] = Math.sqrt(1.0 - (cosz[0] * cosz[0]) - (cosz[1] * cosz[1]));
                    }
                }
            }
        }

        leng = Math.sqrt(cosx[2] * cosx[2] + cosy[2] * cosy[2] + cosz[2] * cosz[2]);

        cosx[2] = cosx[2] / leng;
        cosy[2] = cosy[2] / leng;
        cosz[2] = cosz[2] / leng;

        for (i = 0; i < 3; i++) {
            if (cosx[i] == 0.0) cosx[i] = 0.001;
            if (cosy[i] == 0.0) cosy[i] = 0.001;
            if (cosz[i] == 0.0) cosz[i] = 0.001;
        }

        if (!hideLegend) {
            ImagePlus imp0 = NewImage.createRGBImage("IHC Profiler", 350, 65, 1, 0);
            ImageProcessor ip0 = imp0.getProcessor();
            ip0.setFont(new Font("Monospaced", Font.BOLD, 11));
            ip0.setAntialiasedText(true);
            ip0.setColor(Color.black);
            ip0.moveTo(10, 15);
            ip0.drawString("Colour deconvolution: " + myStain);
            ip0.setFont(new Font("Monospaced", Font.PLAIN, 10));

            for (i = 0; i < 3; i++) {
                ip0.setRoi(10, 18 + i * 15, 14, 14);
                ip0.setColor(
                        (((255 - (int) (255.0 * cosx[i])) & 0xff) << 16) +
                                (((255 - (int) (255.0 * cosy[i])) & 0xff) << 8) +
                                (((255 - (int) (255.0 * cosz[i])) & 0xff)));
                ip0.fill();
                ip0.setFont(new Font("Monospaced", Font.PLAIN, 10));
                ip0.setAntialiasedText(true);
                ip0.setColor(Color.black);
                ip0.moveTo(27, 32 + i * 15);
                ip0.drawString("Colour_" + (i + 1) + " R:" + (float) cosx[i] + ", G:" + (float) cosy[i] + ", B:" + (float) cosz[i]);
            }
            imp0.show();
            imp0.updateAndDraw();
        }

        if (doIshow) {
            IJ.log(myStain + " Vector Matrix ---");
            for (i = 0; i < 3; i++) {
                IJ.log("Colour[" + (i + 1) + "]:\n" +
                        "  R" + (i + 1) + ": " + (float) MODx[i] + "\n" +
                        "  G" + (i + 1) + ": " + (float) MODy[i] + "\n" +
                        "  B" + (i + 1) + ": " + (float) MODz[i] + "\n \n");
            }

            IJ.log(myStain + " Java code ---");
            IJ.log("\t\tif (myStain.equals(\"New_Stain\")){");
            IJ.log("\t\t// This is the New_Stain");
            for (i = 0; i < 3; i++) {
                IJ.log("\t\t\tMODx[" + i + "]=" + (float) cosx[i] + ";\n" +
                        "\t\t\tMODy[" + i + "]=" + (float) cosy[i] + ";\n" +
                        "\t\t\tMODz[" + i + "]=" + (float) cosz[i] + ";\n\n");
            }
            IJ.log("}");
        }

        //matrix inversion
        A = cosy[1] - cosx[1] * cosy[0] / cosx[0];
        V = cosz[1] - cosx[1] * cosz[0] / cosx[0];
        C = cosz[2] - cosy[2] * V / A + cosx[2] * (V / A * cosy[0] / cosx[0] - cosz[0] / cosx[0]);
        q[2] = (-cosx[2] / cosx[0] - cosx[2] / A * cosx[1] / cosx[0] * cosy[0] / cosx[0] + cosy[2] / A * cosx[1] / cosx[0]) / C;
        q[1] = -q[2] * V / A - cosx[1] / (cosx[0] * A);
        q[0] = 1.0 / cosx[0] - q[1] * cosy[0] / cosx[0] - q[2] * cosz[0] / cosx[0];
        q[5] = (-cosy[2] / A + cosx[2] / A * cosy[0] / cosx[0]) / C;
        q[4] = -q[5] * V / A + 1.0 / A;
        q[3] = -q[4] * cosy[0] / cosx[0] - q[5] * cosz[0] / cosx[0];
        q[8] = 1.0 / C;
        q[7] = -q[8] * V / A;
        q[6] = -q[7] * cosy[0] / cosx[0] - q[8] * cosz[0] / cosx[0];

        // initialize 3 output colour stacks
        ImageStack[] outputstack = new ImageStack[3];
        for (i = 0; i < 3; i++) {
            for (j = 0; j < 256; j++) {
                rLUT[255 - j] = (byte) (255.0 - (double) j * cosx[i]);
                gLUT[255 - j] = (byte) (255.0 - (double) j * cosy[i]);
                bLUT[255 - j] = (byte) (255.0 - (double) j * cosz[i]);
            }
            IndexColorModel cm = new IndexColorModel(8, 256, rLUT, gLUT, bLUT);
            outputstack[i] = new ImageStack(width, height, cm);
        }

        // translate ------------------
        int imagesize = width * height;
        for (int imagenum = 1; imagenum <= stack.getSize(); imagenum++) {
            int[] pixels = (int[]) stack.getPixels(imagenum);
            String label = stack.getSliceLabel(imagenum);
            byte[][] newpixels = new byte[3][];
            newpixels[0] = new byte[imagesize];
            newpixels[1] = new byte[imagesize];
            newpixels[2] = new byte[imagesize];

            for (j = 0; j < imagesize; j++) {
                // log transform the RGB data
                int R = (pixels[j] & 0xff0000) >> 16;
                int G = (pixels[j] & 0x00ff00) >> 8;
                int B = (pixels[j] & 0x0000ff);
                double Rlog = -((255.0 * Math.log(((double) R + 1) / 255.0)) / log255);
                double Glog = -((255.0 * Math.log(((double) G + 1) / 255.0)) / log255);
                double Blog = -((255.0 * Math.log(((double) B + 1) / 255.0)) / log255);
                for (i = 0; i < 3; i++) {
                    // rescale to match original paper values
                    double Rscaled = Rlog * q[i * 3];
                    double Gscaled = Glog * q[i * 3 + 1];
                    double Bscaled = Blog * q[i * 3 + 2];
                    double output = Math.exp(-((Rscaled + Gscaled + Bscaled) - 255.0) * log255 / 255.0);
                    if (output > 255) output = 255;
                    newpixels[i][j] = (byte) (0xff & (int) (Math.floor(output + .5)));
                }
            }
            // add new values to output images
            outputstack[0].addSlice(label, newpixels[0]);
            outputstack[1].addSlice(label, newpixels[1]);
            outputstack[2].addSlice(label, newpixels[2]);
        }
        new ImagePlus(title + "-(Hematoxylin Stain)", outputstack[0]).show();
        new ImagePlus(title + "-(DAB Stain)", outputstack[1]).show();
        //new ImagePlus(title+"-(Colour_3)",outputstack[2]).show();

        if (myMode.equals(MODES[0])) {

            IJ.runMacroFile("IHC_Profiler", null);

        }  else if (myMode.equals(MODES[1])) {

            ThresholdAdjuster ta = new ThresholdAdjuster();
            ta.run();

        }
    }

    void getmeanRGBODfromROI(int i, double[] rgbOD, ImagePlus imp) {
        //get a ROI and its mean optical density. GL
        int[] xyzf = new int[4]; //[0]=x, [1]=y, [2]=z, [3]=flags
        int x1, y1, x2, y2, h = 0, w = 0, px = 0, py = 0, x, y, p;
        double log255 = Math.log(255.0);
        ImageProcessor ip = imp.getProcessor();
        int mw = ip.getWidth() - 1;
        int mh = ip.getHeight() - 1;

        IJ.showMessage("Select ROI for Colour_" + (i + 1) + ".\n \n(Right-click to end)");
        getCursorLoc(xyzf, imp);
        while ((xyzf[3] & 4) != 0) {  //trap until right released
            getCursorLoc(xyzf, imp);
            IJ.wait(20);
        }

        while (((xyzf[3] & 16) == 0) && ((xyzf[3] & 4) == 0)) { //trap until one is pressed
            getCursorLoc(xyzf, imp);
            IJ.wait(20);
        }

        rgbOD[0] = 0;
        rgbOD[1] = 0;
        rgbOD[2] = 0;

        if ((xyzf[3] & 4) == 0) {// right was not pressed, but left (ROI) was
            x1 = xyzf[0];
            y1 = xyzf[1];
            //IJ.write("first point x:" + x1 + "  y:" + y1);
            x2 = x1;
            y2 = y1;
            while ((xyzf[3] & 4) == 0) {//until right pressed
                getCursorLoc(xyzf, imp);
                if (xyzf[0] != x2 || xyzf[1] != y2) {
                    if (xyzf[0] < 0) xyzf[0] = 0;
                    if (xyzf[1] < 0) xyzf[1] = 0;
                    if (xyzf[0] > mw) xyzf[0] = mw;
                    if (xyzf[1] > mh) xyzf[1] = mh;
                    x2 = xyzf[0];
                    y2 = xyzf[1];
                    w = x2 - x1 + 1;
                    h = y2 - y1 + 1;
                    if (x2 < x1) {
                        px = x2;
                        w = (x1 - x2) + 1;
                    } else px = x1;
                    if (y2 < y1) {
                        py = y2;
                        h = (y1 - y2) + 1;
                    } else py = y1;
                    IJ.makeRectangle(px, py, w, h);
                    //IJ.write("Box x:" + x2 +"  y:" + y2+" w:"+w+" h:"+h);
                }
                IJ.wait(20);
            }
            while ((xyzf[3] & 16) != 0) {  //trap until left released
                getCursorLoc(xyzf, imp);
                IJ.wait(20);
            }

            for (x = px; x < (px + w); x++) {
                for (y = py; y < (py + h); y++) {
                    p = ip.getPixel(x, y);
                    // rescale to match original paper values
                    rgbOD[0] = rgbOD[0] + (-((255.0 * Math.log(((double) ((p & 0xff0000) >> 16) + 1) / 255.0)) / log255));
                    rgbOD[1] = rgbOD[1] + (-((255.0 * Math.log(((double) ((p & 0x00ff00) >> 8) + 1) / 255.0)) / log255));
                    rgbOD[2] = rgbOD[2] + (-((255.0 * Math.log(((double) ((p & 0x0000ff)) + 1) / 255.0)) / log255));
                }
            }
            rgbOD[0] = rgbOD[0] / (w * h);
            rgbOD[1] = rgbOD[1] / (w * h);
            rgbOD[2] = rgbOD[2] / (w * h);
        }
        IJ.run("Select None");
    }

    void getCursorLoc(int[] xyzf, ImagePlus imp) {
        ImageWindow win = imp.getWindow();
        ImageCanvas ic = win.getCanvas();
        Point p = ic.getCursorLoc();
        xyzf[0] = p.x;
        xyzf[1] = p.y;
        xyzf[2] = imp.getCurrentSlice() - 1;
        xyzf[3] = ic.getModifiers();
    }

    private void makeVectorHDAB(double[] MODx, double[] MODy, double[] MODz) {
        // 3,3-diamino-benzidine tetrahydrochloride
        // Haem matrix
        MODx[0] = 0.684;
        MODy[0] = 0.696;
        MODz[0] = 0.183;
        // DAB matrix
        MODx[1] = 0.250;
        MODy[1] = 0.500;
        MODz[1] = 0.850;
        // Zero matrix
        MODx[2] = 0.0;
        MODy[2] = 0.0;
        MODz[2] = 0.0;
    }
}